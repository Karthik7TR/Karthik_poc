package com.thomsonreuters.uscl.ereader.xpp.transformation.generate.title.metadata.step;

import java.io.File;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.annotation.Resource;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.Marshaller;
import javax.xml.transform.Transformer;

import com.thomsonreuters.uscl.ereader.common.filesystem.AssembleFileSystem;
import com.thomsonreuters.uscl.ereader.common.notification.step.FailureNotificationType;
import com.thomsonreuters.uscl.ereader.common.notification.step.SendFailureNotificationPolicy;
import com.thomsonreuters.uscl.ereader.common.proview.feature.FeaturesListBuilder;
import com.thomsonreuters.uscl.ereader.common.proview.feature.ProviewFeaturesListBuilderFactory;
import com.thomsonreuters.uscl.ereader.common.publishingstatus.step.SavePublishingStatusPolicy;
import com.thomsonreuters.uscl.ereader.common.xslt.TransformationCommand;
import com.thomsonreuters.uscl.ereader.common.xslt.TransformationCommandBuilder;
import com.thomsonreuters.uscl.ereader.core.book.domain.BookDefinition;
import com.thomsonreuters.uscl.ereader.core.book.model.BookTitleId;
import com.thomsonreuters.uscl.ereader.core.book.model.Version;
import com.thomsonreuters.uscl.ereader.proview.Doc;
import com.thomsonreuters.uscl.ereader.proview.Feature;
import com.thomsonreuters.uscl.ereader.proview.TitleMetadata;
import com.thomsonreuters.uscl.ereader.request.domain.XppBundle;
import com.thomsonreuters.uscl.ereader.xpp.strategy.type.BundleFileType;
import com.thomsonreuters.uscl.ereader.xpp.transformation.step.XppTransformationStep;
import lombok.Getter;
import lombok.SneakyThrows;
import org.apache.commons.io.FileUtils;
import org.jetbrains.annotations.NotNull;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;

/**
 * Step will generate TitleMetadata object according to BookDefinition object from job execution context.
 * TitleMetadata object will be serialized as xml file.
 * title.xml file will be generated by performing xsl transformation to toc.xml file,
 * metadata for title.xml will be extracted from serialized TitleMetadata object.
 *
 * This component use jaxb to serialize object to xml file.
 */
@SendFailureNotificationPolicy(FailureNotificationType.XPP)
@SavePublishingStatusPolicy
public class GenerateTitleMetadataStep extends XppTransformationStep {
    @Value("${xpp.toc.to.title.xsl}")
    private File tocToTitleXsl;
    @Resource(name = "assembleFileSystem")
    private AssembleFileSystem assembleFileSystem;
    @Autowired
    private ProviewFeaturesListBuilderFactory proviewFeaturesListBuilderFactory;

    @Override
    public void executeTransformation() throws Exception {
        FileUtils.forceMkdir(fileSystem.getTitleMetadataDirectory(this));
        if (getBookDefinition().isSplitBook()) {
            getSplitPartsBundlesMap().forEach((partNumber, bundles) -> {
                generateTitleMetadata(collectDocumentsForBundles(bundles), partNumber);
            });
        } else {
            generateTitleMetadata(collectDocumentsForBundles(getXppBundles()), null);
        }
    }

    private List<Doc> collectDocumentsForBundles(@NotNull final List<XppBundle> bundles) {
        final DocumentsCollector documentsCollector = new DocumentsCollector();
        bundles.forEach(bundle -> {
            final String materialNumber = bundle.getMaterialNumber();
            bundle.getOrderedFileList().stream()
                .map(BundleFileType::getHtmlDocFileNameFilter)
                .map(fileSystem.getExternalLinksDirectory(this, materialNumber)::list)
                .forEach(documentsNames -> documentsCollector.addDocuments(documentsNames, bundle));
        });
        return documentsCollector.getDocuments();
    }

    private void generateTitleMetadata(final List<Doc> documents, final Integer splitPartNumber) {
        final List<File> inputTocFiles = getSplitPartsBundlesMap().keySet().stream()
            .map(partNumber -> getSplitPartFileOrDefault(partNumber, fileSystem::getTocPartFile, fileSystem::getTocFile))
            .collect(Collectors.toList());
        final File titleXmlFile = getSplitPartFileOrDefault(
            splitPartNumber, assembleFileSystem::getSplitPartTitleXml, assembleFileSystem::getTitleXml);

        final Transformer transformer = transformerBuilderFactory.create().withXsl(tocToTitleXsl).build();
        transformer.setParameter("titleMetadataDoc", saveMetadataAndGetFilePath(documents, splitPartNumber));

        final TransformationCommand command = new TransformationCommandBuilder(transformer, titleXmlFile)
            .withInput(inputTocFiles).build();
        transformationService.transform(command);
    }

    @SneakyThrows
    private String saveMetadataAndGetFilePath(final List<Doc> documents, final Integer splitPartNumber) {
        final BookDefinition bookDefinition = getBookDefinition();
        final TitleMetadata titleMetadata = TitleMetadata.builder(bookDefinition)
            .versionNumber(getBookVersionString())
            .fullyQualifiedTitleId(getTitleId(splitPartNumber))
            .displayName(getDisplayName(splitPartNumber))
            .proviewFeatures(getFeatures(splitPartNumber, documents))
            .artworkFile(getSplitPartFileOrDefault(
                splitPartNumber, assembleFileSystem::getSplitPartArtworkFile, assembleFileSystem::getArtworkFile))
            .assetFilesFromDirectory(getSplitPartFileOrDefault(splitPartNumber,
                assembleFileSystem::getSplitPartAssetsDirectory, assembleFileSystem::getAssetsDirectory))
            .documents(documents)
            .build();

        final File titleBookDefinitionFile = getSplitPartFileOrDefault(
            splitPartNumber, fileSystem::getSplitPartTitleMetadataFile, fileSystem::getTitleMetadataFile);
        final Marshaller marshaller = JAXBContext.newInstance(TitleMetadata.class).createMarshaller();
        marshaller.marshal(titleMetadata, titleBookDefinitionFile);
        return titleBookDefinitionFile.getAbsolutePath().replace("\\", "/");
    }

    private List<Feature> getFeatures(final Integer splitPartNumber, final List<Doc> documents) {
        final FeaturesListBuilder featureListBuilder = proviewFeaturesListBuilderFactory.create(getBookDefinition())
            .withBookVersion(getBookVersion())
            .withPageNumbers(true);
        Optional.ofNullable(splitPartNumber)
            .map(partNumber -> new BookTitleId(partNumber.toString(),
                    new Version(BigInteger.ZERO, BigInteger.ZERO)))
            .ifPresent(titleId -> featureListBuilder.forTitleId(titleId)
                .withTitleDocs(Collections.singletonMap(titleId, documents)));
        return featureListBuilder.getFeatures();
    }

    private String getDisplayName(final Integer splitPartNumber) {
        final BookDefinition bookDefinition = getBookDefinition();
        return Optional.ofNullable(splitPartNumber)
            .map(partNumber -> String.format("%s (eBook %s of %s)", bookDefinition.getProviewDisplayName(), partNumber, getSplitPartsBundlesMap().size()))
            .orElseGet(bookDefinition::getProviewDisplayName);
    }

    private static class DocumentsCollector {
        @Getter
        private final List<Doc> documents = new ArrayList<>();

        public void addDocuments(@NotNull final String[] documentsNames, @NotNull final XppBundle bundle) {
            Stream.of(documentsNames)
                .map(DocumentName::new)
                .sorted(Comparator.comparingInt(DocumentName::getOrder))
                .distinct()
                .map(docName -> new Doc(docName.getDocFamilyUuid(), docName.getOriginalFileName(), 0, null))
                .map(doc -> {
                    if (bundle.isPocketPartPublication()) {
                        return new Doc(doc.getId() + "_pp", doc.getSrc(), doc.getSplitTitlePart(), doc.getImageIdList());
                    } else {
                        return doc;
                    }
                })
                .forEach(documents::add);
        }
    }
}
